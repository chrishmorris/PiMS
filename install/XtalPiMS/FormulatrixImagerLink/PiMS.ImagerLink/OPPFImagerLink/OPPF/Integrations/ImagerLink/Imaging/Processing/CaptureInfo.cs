/*
 * CapturePoint.cs - implementation of Formulatrix.Integrations.ImagerLink.Imaging.ICapturePoint.
 * Copyright 2010 Jonathan Diprose <jon@strubi.ox.ac.uk>
 */

using System;

using Formulatrix.Common.Utility;
using Formulatrix.Integrations.ImagerLink;
using Formulatrix.Integrations.ImagerLink.Imaging;
using Formulatrix.Integrations.ImagerLink.Imaging.Processing;

namespace OPPF.Integrations.ImagerLink.Imaging.Processing
{
	/// <summary>
    /// Contains the information about a stack of images that were captured at a particular location.
	/// </summary>
    /// <remarks>
    /// NB THIS INFORMATION IS OUT OF DATE!
    /// 
    /// 1. The following IProperty names may be available for completed images. Note that RockImagerProcessor tries to save these values using the IImageProcessor method 'SetCaptureInfo', so your implementation will have to handle the resulting call. Alternatively, these properties are included in the DONE file XML generated by RockImager. NOTE: There is currently no IProperty returned that gives the LightPath (visible or UV), although that information can be received in the DONE file in the <LightPath> tag, or using the 5th number in the filename. The number 0 indicates visible light, and the number 1 indicates UV.
    /// 
    /// Visible Light:
    /// 
    /// ImagingCondenser
    /// Double as a percentage
    /// 
    /// ImagingPolarizer
    /// Double from 0-360 in degrees of rotation
    /// 
    /// FixedBrightField
    /// Double from 0-100 as a percentage
    /// 
    /// ImagingDarkField
    /// Double from 0-100 as a percentage
    /// *ImagingDarkField is only returned on machines that are equipped with dark field hardware.
    /// 
    /// WhiteBalance
    /// Three comma separated doubles indicating red, green, and blue (in that order) scaling factors applied to the image.
    /// 
    /// Gamma
    /// Double indicating the gamma setting applied to the image
    /// 
    /// Gain
    /// Double indicating the gain applied to the camera
    /// 
    /// FixedExposure
    /// Double indicating the exposure time of the camera in milliseconds
    /// 
    /// UV Light:
    /// 
    /// GammaUV
    /// Double indicating the gamma setting applied to the image
    /// 
    /// GainUV
    /// Double indicating the gain applied to the camera
    /// 
    /// FixedExposureUV
    /// Double indicating the exposure time of the camera in milliseconds
    /// 
    /// IntensityMapUV
    /// A series of comma separated integers representing key/value pairs. An even number of tokens will always be used. The 'key' of the pair (the first number) indicates an original input pixel intensity and maps to the 'value' of the pair (the second number) which is the output intensity for that particular input. These numbers are intended to be used by constructing a lookup table for all pixel values - intermediate values not listed are interpolated using the slope from successive numbers + the offset of the first number. For instance, if I have the IntensityMap '0,1,25,51,100,100,255,255' then all pixel intensities between 0 and 25 were halved on output, then 1 was added as the offset. The values between 100 to 255 remain untouched because the slope is 1 and there is no offset. By default, the values 0,0,255,255 are recorded.
    /// </remarks>
	public class CaptureInfo : ICaptureInfo
	{
		private IFocalPoint[] _focalPoints;
		private ImageRect _location;
		private IProperty[] _properties;

        /// <summary>
        /// Zero-arg constructor
        /// </summary>
        /// <remarks>All attributes are set to null.</remarks>
        public CaptureInfo()
        {
            SetFocalPoints(null);
            SetLocation(null);
            SetProperties(null);
        }

        #region ICaptureInfo Members

        /// <summary>
        /// The Z heights and relative computer focus values used to determine where to capture the image.
        /// </summary>
        IFocalPoint[] ICaptureInfo.FocalPoints
		{
			get
			{
				return _focalPoints;
			}
		}

        /// <summary>
        /// The center of the capture and size in micrometers.
        /// </summary>
        ImageRect ICaptureInfo.Location
		{
			get
			{
				return _location;
			}
		}

        /// <summary>
        /// The properties used to capture this stack of images, such as exposure, resolution, etc.
        /// </summary>
        IProperty[] ICaptureInfo.Properties
		{
			get
			{
				return _properties;
			}
		}

		#endregion

        #region Set methods for interface properties

        public void SetFocalPoints(IFocalPoint[] focalPoints)
        {
            _focalPoints = focalPoints;
        }

        public void SetLocation(ImageRect location)
        {
            _location = location;
        }

        public void SetProperties(IProperty[] properties)
        {
				_properties = properties;
        }

        #endregion


        /// <summary>
        /// Custom ToString to display more information.
        /// </summary>
        /// <param name="captureInfo"></param>
        /// <returns></returns>
        public static string ToString(ICaptureInfo captureInfo)
        {
            string msg = "[FocalPoints=";
            if (null != captureInfo.FocalPoints)
            {
                msg = msg + "[";
                for (int i = 0; i < captureInfo.FocalPoints.Length; i++)
                {
                    if (i > 0) {
                        msg = msg + ",";
                    }
                    msg = msg + FocalPoint.ToString(captureInfo.FocalPoints[i]);
                }
                msg = msg + "]";
            }
            else
            {
                msg = msg + "null";
            }
            msg = ";Location=";
            if (null != captureInfo.Location)
            {
                msg = msg + captureInfo.Location.ToString();
            }
            else
            {
                msg = msg + "null";
            }
            msg = msg + ";Properties=";
            if (null != captureInfo.Properties)
            {
                msg = msg + "[";
                for (int i = 0; i < captureInfo.Properties.Length; i++)
                {
                    if (i > 0) {
                        msg = msg + ",";
                    }
                    msg = msg + Property.ToString(captureInfo.Properties[i]);
                }
                msg = msg + "]";
            }
            else
            {
                msg = msg + "null";
            }
            msg = msg + "]";
            return msg;
        }
	}
}
